# -*- coding: utf-8 -*-
"""Plano_Int_2_0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Yr8LaG_AtSFpIAbKgfbEtnTqjGnHkktx
"""

from google.colab import drive
import os

# 1. Montar Google Drive
# Esto te pedir√° permiso para acceder a tus archivos la primera vez
drive.mount('/content/drive')

# 2. Definir la ruta de la carpeta donde est√°n el c√≥digo, el excel y el plano
# Ajusta 'Nombre_De_Tu_Carpeta' al nombre real en tu Drive
# Si est√° dentro de otra, usa 'Carpeta1/Carpeta2'
ruta_carpeta = '/content/drive/MyDrive/Obra Campos del Sur II'

# 3. Cambiar el directorio de trabajo a esa carpeta
if os.path.exists(ruta_carpeta):
    os.chdir(ruta_carpeta)
    print(f"Directorio cambiado a: {os.getcwd()}")
    print("Archivos encontrados:", os.listdir())
else:
    print("‚ö†Ô∏è Error: La ruta no existe. Verifica el nombre de la carpeta.")

import cv2
import numpy as np
from matplotlib import pyplot as plt

# 1. Cargar la imagen
img = cv2.imread('plano.png')
h, w, _ = img.shape
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 2. Umbralizaci√≥n para detectar bloques negros
_, thresh = cv2.threshold(gray, 60, 255, cv2.THRESH_BINARY_INV)

# 3. Limpieza de ruido
kernel = np.ones((3,3), np.uint8)
opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel)

# 4. Encontrar contornos
contours, _ = cv2.findContours(opening, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

casas_geometria = []
debug_img = img.copy()

def pixel_to_folium(pt, h):
    px_x, px_y = pt
    # latitud = Altura_Total - pixel_y (esto invierte el eje para Folium)
    # longitud = pixel_x
    lat = float(h - px_y)
    lng = float(px_x)
    return [lng, lat]

centroides_casas = []

for cnt in contours:
    area = cv2.contourArea(cnt)
    perimetro = cv2.arcLength(cnt, True)

    if perimetro == 0: continue

    # Circularidad para descartar l√≠neas
    circularidad = (4 * np.pi * area) / (perimetro ** 2)

    # Filtros de √°rea y forma
    if 200 < area < 4000 and circularidad > 0.4:
        epsilon = 0.03 * perimetro
        approx = cv2.approxPolyDP(cnt, epsilon, True)

        if 4 <= len(approx) <= 10:
            cv2.drawContours(debug_img, [approx], -1, (0, 255, 0), 2)

            M = cv2.moments(cnt)
            if M["m00"] != 0:
              cx = M["m10"] / M["m00"]
              cy = M["m01"] / M["m00"]
              centroides_casas.append((cx, cy))

            # --- CORRECCI√ìN CLAVE PARA FOLIUM ---
            # Folium espera [Y, X].
            # En modo Simple, el origen [0,0] suele estar abajo a la izquierda.
            # Invertimos el eje Y respecto al alto total (h) para que no salga vertical.
            coords = []
            for pt in approx:
              px_x = float(pt[0][0])
              px_y = float(pt[0][1])
              coords.append(pixel_to_folium((px_x, px_y), h))

            coords.append(coords[0]) # Cerrar pol√≠gono
            casas_geometria.append(coords)

print(f"√âXITO: Se detectaron {len(casas_geometria)} viviendas.")

# Visualizaci√≥n de Debug (Deber√≠a verse igual de bien que antes)
plt.figure(figsize=(15, 7))
plt.imshow(cv2.cvtColor(debug_img, cv2.COLOR_BGR2RGB))
plt.title("Detecci√≥n de Viviendas (Verde)")
plt.axis('off')
plt.show()

centroides = []

for i, geo in enumerate(casas_geometria):
    xs = [p[0] for p in geo[:-1]]
    ys = [p[1] for p in geo[:-1]]

    cx = sum(xs) / len(xs)
    cy_mapa = sum(ys) / len(ys)

    # --- CORRECCI√ìN ---
    # Revertimos la coordenada Y para que coincida con las reglas de MANZANAS (P√≠xeles originales)
    # Si no hacemos esto, la l√≥gica de manzanas estar√° invertida verticalmente.
    cy_pixel = h - cy_mapa

    centroides.append({
        "idx": i,
        "cx": cx,
        "cy": cy_pixel # Usamos la coordenada de pixel para la l√≥gica
    })

# =========================
# 1. ESTRUCTURA DE CASAS
# =========================

casas = []

for c in centroides:
    casas.append({
        "idx": c["idx"],
        "cx": c["cx"],
        "cy": c["cy"],
        "geometry": casas_geometria[c["idx"]]
    })


# =========================
# 2. DEFINICI√ìN DE MANZANAS
# =========================

# Ajusta SOLO las condiciones si alguna manzana cambia,
# pero NO el resto del c√≥digo
MANZANAS = {
    "A": lambda x,y: x > 1400 and y < 500,
    "B": lambda x,y: x > 1400 and 500 <= y < 850,
    "C": lambda x,y: 770 < x <= 1400 and y < 500,
    "D": lambda x,y: 1250 < x <= 1400 and 550 <= y < 730,
    "E": lambda x,y: 770 < x <= 1400 and y >= 800,
    "F": lambda x,y: 1000 < x <= 1230 and 550 <= y < 730,
    "G": lambda x,y: 80 <= x < 775 and y < 500,
    "H": lambda x,y: 570 < x < 775 and 550 <= y < 750,
    "I": lambda x,y: 380 < x <= 710 and 550 <= y < 750,
    "J": lambda x,y: x <= 780 and y >= 780,
    "K": lambda x,y: 220 < x <= 380 and 550 <= y < 750,
    "L": lambda x,y: x <= 215 and 550 <= y < 750
}


# =========================
# 3. ASIGNACI√ìN CASA ‚Üí MANZANA
# =========================

mapa_manzanas = {}
casas_por_manzana = {}

for casa in casas:
    asignada = False

    for manzana, condicion in MANZANAS.items():
        if condicion(casa["cx"], casa["cy"]):
            mapa_manzanas[casa["idx"]] = manzana
            casas_por_manzana.setdefault(manzana, []).append(casa)
            asignada = True
            break

    if not asignada:
        mapa_manzanas[casa["idx"]] = "SIN"
        casas_por_manzana.setdefault("SIN", []).append(casa)


# DEBUG OPCIONAL
for m, lst in casas_por_manzana.items():
    print(f"Manzana {m}: {len(lst)} casas")

total = sum(len(casas) for casas in casas_por_manzana.values())
print(f"Total de casas asignadas: {total}")

if "SIN_MANZANA" in casas_por_manzana:
    print("‚ö†Ô∏è Casas sin manzana:")
    for c in casas_por_manzana["SIN_MANZANA"]:
        print(f"idx={c['idx']} cx={int(c['cx'])} cy={int(c['cy'])}")

from collections import defaultdict

casas_por_manzana = defaultdict(list)

for casa in centroides:
    x, y = casa["cx"], casa["cy"]
    asignada = False

    for letra, regla in MANZANAS.items():
        if regla(x, y):
            casas_por_manzana[letra].append(casa)
            asignada = True
            break

    if not asignada:
        casas_por_manzana["SIN_MANZANA"].append(casa)

total = 0
for m, casas in casas_por_manzana.items():
    print(f"Manzana {m}: {len(casas)} casas")
    total += len(casas)

print("TOTAL:", total)

# ========================================================
# 1. FUNCIONES DE ORDENAMIENTO (ESTRUCTURA BASE)
# ========================================================

def agrupar_en_filas(casas, tolerancia=25):
    filas = []
    for c in sorted(casas, key=lambda x: x["cy"]):
        agregado = False
        for fila in filas:
            if abs(fila[0]["cy"] - c["cy"]) < tolerancia:
                fila.append(c); agregado = True; break
        if not agregado: filas.append([c])
    return filas

def ordenar_rectangular(casas):
    filas = agrupar_en_filas(casas)
    casas_ordenadas = []
    for fila in filas:
        fila_ordenada = sorted(fila, key=lambda c: c["cx"])
        casas_ordenadas.extend(fila_ordenada)
    return casas_ordenadas

def ordenar_lineal(casas, modo):
    if modo == "LR_T": return sorted(casas, key=lambda c: (c["cy"], c["cx"]))
    if modo == "RL_T": return sorted(casas, key=lambda c: (c["cy"], -c["cx"]))
    return casas

def ordenar_perimetro(casas, es_especial=False):
    if not casas: return []
    min_x, max_x = min(c['cx'] for c in casas), max(c['cx'] for c in casas)
    min_y, max_y = min(c['cy'] for c in casas), max(c['cy'] for c in casas)
    tol = 30
    muro_izq, muro_sup, muro_der, muro_inf = [], [], [], []
    procesadas = set()

    candidatos_izq = sorted([c for c in casas if c['cx'] < min_x + tol], key=lambda x: x['cy'], reverse=True)
    for c in candidatos_izq: muro_izq.append(c); procesadas.add(c['idx'])

    candidatos_sup = sorted([c for c in casas if c['cy'] < min_y + tol and c['idx'] not in procesadas], key=lambda x: x['cx'])
    for c in candidatos_sup: muro_sup.append(c); procesadas.add(c['idx'])

    candidatos_der = sorted([c for c in casas if c['cx'] > max_x - tol and c['idx'] not in procesadas], key=lambda x: x['cy'])
    for c in candidatos_der: muro_der.append(c); procesadas.add(c['idx'])

    candidatos_inf = sorted([c for c in casas if c['cy'] > max_y - tol and c['idx'] not in procesadas], key=lambda x: x['cx'], reverse=True)
    for c in candidatos_inf: muro_inf.append(c); procesadas.add(c['idx'])

    orden_base = muro_izq + muro_sup + muro_der + muro_inf
    for c in casas:
        if c['idx'] not in procesadas: orden_base.append(c)

    if es_especial and len(orden_base) > 2:
        return [orden_base[0], orden_base[-1]] + orden_base[1:-1]
    return orden_base

# ========================================================
# 2. EJECUCI√ìN CON CONDICIONALES INDEPENDIENTES
# ========================================================
mapa_numeros = {}
MANZANAS_ESPIRAL_ESPECIAL = {"D", "F", "H"}
ORDEN_MANZANA_LINEAL = {"A": "LR_T", "C": "LR_T", "E": "RL_T", "G": "LR_T", "J": "LR_T"}

for manzana, casas_lista in casas_por_manzana.items():
    if manzana == "SIN_MANZANA": continue

    casas_ord = []

    # --- CONDICIONAL MANZANA L (Casas 10 y 11) ---
    if manzana == "L":
        casas_ord = ordenar_perimetro(casas_lista, es_especial=False)
        if len(casas_ord) >= 2:
            # Swap de las √∫ltimas dos para corregir inversi√≥n
            casas_ord[-1], casas_ord[-2] = casas_ord[-2], casas_ord[-1]

    # --- CONDICIONAL MANZANAS I y K (Casas 11 y 12, modo especial) ---
    elif manzana in ["I", "K"]:
        casas_ord = ordenar_perimetro(casas_lista, es_especial=True)
        if len(casas_ord) >= 2:
            # Swap de las √∫ltimas dos de la lista corregida (sin tocar la casa 2)
            casas_ord[-1], casas_ord[-2] = casas_ord[-2], casas_ord[-1]

    # --- RESTO DE MANZANAS ---
    elif manzana in MANZANAS_ESPIRAL_ESPECIAL:
        casas_ord = ordenar_perimetro(casas_lista, es_especial=True)
    elif manzana == "B":
        casas_ord = ordenar_rectangular(casas_lista)
    else:
        if manzana == "C":
            filas = agrupar_en_filas(casas_lista, tolerancia=40)
            casas_ord = sorted(filas[0], key=lambda c: c["cx"])
        else:
            modo = ORDEN_MANZANA_LINEAL.get(manzana, "LR_T")
            casas_ord = ordenar_lineal(casas_lista, modo)

    # ASIGNACI√ìN FINAL
    for n, casa in enumerate(casas_ord, start=1):
        mapa_numeros[casa["idx"]] = n

print(f"‚úÖ mapa_numeros corregido: L (10-11), I y K (11-12) con casa 2 fija.")

debug = img.copy()

for c in centroides:
    cx, cy = int(c["cx"]), int(c["cy"])
    cv2.circle(debug, (cx, cy), 6, (0,0,255), -1)

plt.figure(figsize=(12,6))
plt.imshow(cv2.cvtColor(debug, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.show()

import pandas as pd
import re

file_path = '135-CR-CAMPOS DEL SUR 2 (VIVIENDAS_SEDE SOCIAL.1).xlsx'
excel_file = pd.ExcelFile(file_path)
dict_avances = {}

def es_partida_real(codigo):
    if not isinstance(codigo, str): return False
    return len(re.findall(r'\.', codigo.strip())) >= 2

print(f"--- INICIO DE DEBUG (ESCANEO DE FILA INFERIOR) ---")

for sheet_name in excel_file.sheet_names:
    if "MANZ." in sheet_name.upper():
        letra_mz = sheet_name.split('.')[-1].strip()

        # Leemos la hoja sin encabezados primero
        df_raw = pd.read_excel(excel_file, sheet_name=sheet_name, header=None)

        # 1. Localizar la fila del t√≠tulo "VIVIENDA LOTE"
        idx_titulo = None
        for i, row in df_raw.iterrows():
            row_str = " ".join([str(v).upper() for v in row.values])
            if "VIVIENDA" in row_str and "LOTE" in row_str:
                idx_titulo = i
                break

        if idx_titulo is None:
            print(f"‚ö†Ô∏è Manzana {letra_mz}: No se hall√≥ el texto 'VIVIENDA LOTE'")
            continue

        # 2. Los n√∫meros est√°n en la fila SIGUIENTE (idx_titulo + 1)
        idx_numeros = idx_titulo + 1
        fila_numeros = df_raw.iloc[idx_numeros]

        columnas_casas_info = [] # (indice_columna, numero_casa)

        for col_idx, valor in enumerate(fila_numeros):
            val_clean = str(valor).strip()
            # Buscamos si el valor es un n√∫mero puro
            if val_clean.isdigit():
                num_casa = int(val_clean)
                columnas_casas_info.append((col_idx, num_casa))

        if not columnas_casas_info:
            print(f"‚ö†Ô∏è Manzana {letra_mz}: Fila de t√≠tulo en {idx_titulo}, pero fila {idx_numeros} no tiene n√∫meros.")
            # Debug extra: ver qu√© hay en esa fila
            print(f"   Contenido detectado en fila {idx_numeros}: {fila_numeros.values[:10]}...")
            continue

        print(f"‚úÖ Manzana {letra_mz}: {len(columnas_casas_info)} casas encontradas { [c[1] for c in columnas_casas_info] }")

        # 3. Procesar partidas (saltamos hasta despu√©s de la fila de n√∫meros)
        df_datos = pd.read_excel(excel_file, sheet_name=sheet_name, skiprows=idx_numeros + 1)

        # Filtrar solo partidas X.x.x
        col_item_nombre = df_datos.columns[0]
        df_partidas = df_datos[df_datos[col_item_nombre].apply(es_partida_real)]

        total_p = len(df_partidas)

        if total_p > 0:
            for col_idx, num_casa in columnas_casas_info:
                # Usamos iloc para ir a la columna exacta por posici√≥n
                # Restamos 1 o ajustamos si es necesario seg√∫n la lectura de df_datos
                col_data = df_partidas.iloc[:, col_idx]

                completadas = col_data.notna().sum()
                porcentaje = round((completadas / total_p) * 100, 1)
                dict_avances[(letra_mz, num_casa)] = porcentaje

print(f"\n--- FIN DE DEBUG ---")
print(f"Resultado: {len(dict_avances)} registros de avance creados.")

import gspread
from google.colab import auth
from google.auth import default

# ========================================================
# BLOQUE: CARGA DE MAESTRO DE PARTIDAS (FILTRO)
# ========================================================
# Este bloque solo se encarga de definir qu√© filas del Excel
# original deben contarse para el promedio.

try:
    # 1. Abrimos el nuevo documento creado por ti
    auth.authenticate_user()
    creds, _ = default()
    gc = gspread.authorize(creds)
    sh_maestro = gc.open('Partidas').sheet1

    # 2. Leemos la primera columna (nombres de las partidas)
    # Limpiamos espacios y convertimos a may√∫sculas para evitar errores de coincidencia
    lista_partidas_maestras = [str(p).strip().upper() for p in sh_maestro.col_values(1) if p]

    def es_partida_valida(nombre_partida):
        """
        Funci√≥n que ser√° usada por el procesador de Excel.
        Compara si la partida del Excel existe en el maestro de Google Sheets.
        """
        return str(nombre_partida).strip().upper() in lista_partidas_maestras

    print(f"‚úÖ Maestro de partidas cargado con √©xito.")
    print(f"üìã Total de partidas maestras detectadas para filtrar: {len(lista_partidas_maestras)}")

except Exception as e:
    print(f"‚ùå Error al cargar el archivo 'Partidas': {e}")
    print("Revisa que el nombre del archivo sea exactamente 'Partidas' y est√© en tu Drive.")
# ========================================================

auth.authenticate_user()
creds, _ = default()
gc = gspread.authorize(creds)

nombre_hoja_obs = 'Pre F1'
sh_obs = gc.open(nombre_hoja_obs)

dict_observaciones = {}
casas_con_obs = set()

print(f"--- Iniciando Escaneo de Pesta√±as ---")

for hoja in sh_obs.worksheets():
    nombre_hoja = hoja.title.strip().upper()

    # Procesamos solo las que tienen MZ en el nombre
    if "MZ" in nombre_hoja:
        # Extraer letra (ej: de "MZ A" sacar "A")
        letra_mz = nombre_hoja.replace("MZ", "").strip()

        # Obtenemos todos los valores como una lista de listas (filas)
        filas = hoja.get_all_values()

        if len(filas) < 2: continue # Hoja vac√≠a

        # Recorremos desde la segunda fila para saltar el encabezado
        for i, fila in enumerate(filas[1:], start=2):
            # Forzamos que la fila tenga al menos 3 o 4 columnas
            if len(fila) < 3: continue

            # ASIGNACI√ìN POR POSICI√ìN:
            # A=0 (Lote), B=1 (Partida), C=2 (Estado), D=3 (Comentario)
            lote_raw = str(fila[0]).strip()
            partida = str(fila[1]).strip()
            estado = str(fila[2]).strip()
            comentario = str(fila[3]).strip() if len(fila) > 3 else "Sin detalle"

            # Intentar convertir Lote a n√∫mero
            try:
                num_casa = int(float(lote_raw))
            except:
                continue # Si no es un n√∫mero, saltamos la fila

            # Comprobaci√≥n (ignora may√∫sculas/min√∫sculas y espacios)
            if estado.lower() == "en proceso":
                key_partida = (letra_mz, num_casa, partida)
                dict_observaciones[key_partida] = comentario
                casas_con_obs.add((letra_mz, num_casa))
                print(f"‚úÖ ¬°√âxito! Encontrado en {nombre_hoja}: Casa {num_casa} - {partida}")

print(f"\n--- RESUMEN FINAL ---")
print(f"Total observaciones: {len(dict_observaciones)}")
print(f"Casas detectadas: {casas_con_obs}")

import openpyxl
import unicodedata
import re

# ========================================================
# 1. CARGA DE LISTA MAESTRA (DOBLE FILTRO: ITEM + NOMBRE)
# ========================================================
try:
    sh_maestro = gc.open('Partidas').sheet1
    # Leemos las dos primeras columnas: [0] es el Item (X.x.x), [1] es el Nombre
    filas_maestras = sh_maestro.get_all_values()

    # Creamos un conjunto de "llaves √∫nicas" combinando ITEM y NOMBRE
    # Ejemplo: "B.1.1-REPLANTEO, TRAZADO Y NIVELES"
    lista_maestra_llaves = set()
    for fila in filas_maestras:
        if len(fila) >= 2:
            item_m = str(fila[0]).strip().upper()
            nom_m = str(fila[1]).strip().upper()
            if item_m and nom_m:
                lista_maestra_llaves.add(f"{item_m}-{nom_m}")

    print(f"‚úÖ Maestro cargado: {len(lista_maestra_llaves)} combinaciones √∫nicas de Item-Nombre detectadas.")

except Exception as e:
    lista_maestra_llaves = set()
    print(f"‚ö†Ô∏è Error cargando maestro: {e}. Se intentar√° procesar sin filtro estricto.")

def es_partida_maestra_estricta(codigo, nombre):
    """Verifica si la combinaci√≥n ITEM-NOMBRE existe en tu lista."""
    if not lista_maestra_llaves: return True
    llave_actual = f"{str(codigo).strip().upper()}-{str(nombre).strip().upper()}"
    return llave_actual in lista_maestra_llaves

def normalizar(txt):
    if not txt: return ""
    txt = str(txt).lower()
    txt = "".join(c for c in unicodedata.normalize('NFD', txt) if unicodedata.category(c) != 'Mn')
    txt = re.sub(r'[^a-z0-9]', '', txt)
    return txt

# ========================================================
# 2. PROCESO DE CRUCE Y C√ÅLCULO
# ========================================================
wb = openpyxl.load_workbook(file_path, data_only=True)
dict_avances = {}
dict_detalles_casas = {}

for sheet_name in wb.sheetnames:
    if "MANZ" in sheet_name.upper():
        ws = wb[sheet_name]
        letra_mz = sheet_name.replace("MANZ.", "").replace("MANZ", "").strip().upper()

        fila_item = None
        for r in range(1, 50):
            if str(ws.cell(row=r, column=1).value).strip().upper() == "ITEM":
                fila_item = r
                break
        if not fila_item: continue

        columnas_casas = []
        for r_search in range(fila_item - 2, fila_item + 3):
            for c in range(3, 150):
                val = ws.cell(row=r_search, column=c).value
                if val and str(val).strip().isdigit():
                    num_casa = int(str(val).strip())
                    if not any(x[1] == num_casa for x in columnas_casas):
                        columnas_casas.append((c, num_casa))

        titulo_act, sub_act = "", ""
        for r in range(fila_item + 1, ws.max_row + 1):
            cell_it = ws.cell(row=r, column=1)
            item_val = str(cell_it.value).strip() if cell_it.value else ""
            desc_val = str(ws.cell(row=r, column=2).value).strip() if ws.cell(row=r, column=2).value else ""

            if not item_val or item_val == "None": continue

            if cell_it.font.bold:
                if "." not in item_val:
                    titulo_act = desc_val; sub_act = ""
                else:
                    sub_act = desc_val

            # --- APLICACI√ìN DEL DOBLE FILTRO ---
            elif es_partida_maestra_estricta(item_val, desc_val):
                for col_idx, num_casa in columnas_casas:
                    v_celda = ws.cell(row=r, column=col_idx).value
                    terminado = pd.notna(v_celda) if hasattr(v_celda, 'notna') else (v_celda is not None and str(v_celda).strip() != "")

                    match_encontrado = False
                    comentario_texto = ""
                    partida_excel_norm = normalizar(desc_val)

                    for (obs_mzn, obs_casa, obs_partida), obs_coment in dict_observaciones.items():
                        if obs_mzn.upper() == letra_mz and int(obs_casa) == int(num_casa):
                            if normalizar(obs_partida) in partida_excel_norm or partida_excel_norm in normalizar(obs_partida):
                                match_encontrado = True
                                comentario_texto = obs_coment
                                break

                    key = (letra_mz, num_casa)
                    if key not in dict_detalles_casas: dict_detalles_casas[key] = []
                    dict_detalles_casas[key].append({
                        'titulo': titulo_act,
                        'subtitulo': sub_act,
                        'partida': f"[{item_val}] {desc_val}", # Guardamos con c√≥digo para el Popup
                        'estado': "‚úÖ" if terminado else "‚ùå",
                        'tiene_obs': match_encontrado,
                        'comentario': comentario_texto
                    })

# 3. C√°lculo final (igual que antes)
for key, lista_partidas in dict_detalles_casas.items():
    total_p = len(lista_partidas)
    hechas = sum(1 for p in lista_partidas if p['estado'] == "‚úÖ")
    if total_p > 0:
        dict_avances[key] = round((hechas / total_p) * 100, 1)

print(f"‚úÖ Filtro doble aplicado. Datos listos.")

# ========================================================
# BLOQUE: RE-ASIGNACI√ìN DE IDS Y CLASIFICACI√ìN (FORZADO)
# ========================================================

# Listas de referencia (formato simplificado)
tipos_ref = {
    "Tipo B": ["D1", "F1", "F8", "I1", "I8", "K1", "K8", "L1", "L7"],
    "Tipo C": ["B3", "B4", "B5", "B6", "B7", "G1"],
    "Tipo D": ["B1", "B2"],
    "Tipo A2": ["E16", "E17"],
    "Tipo A1-N": ["E1", "D11", "F11", "I12", "J21"]
}

# 1. Re-mapeo: Vamos a usar las variables originales del escaneo para recrear las llaves
# mapa_manzanas y mapa_numeros contienen la informaci√≥n real del plano.
dict_tipos_vivienda = {}
nuevas_llaves_coherentes = []

print("üõ†Ô∏è Re-vinculando geometr√≠as con nombres de manzana reales...")

for i in range(len(mapa_manzanas)):
    # Obtenemos los valores que vienen del escaneo
    mz_val = str(mapa_manzanas[i]).strip()
    num_val = str(mapa_numeros[i]).strip()

    # IMPORTANTE: Aqu√≠ es donde el programa suele confundirse.
    # Si mz_val es un n√∫mero ('0', '1'...), intentaremos usar la l√≥gica del Excel.
    # Por ahora, crearemos un ID de b√∫squeda limpio.
    id_busqueda = f"{mz_val}{num_val}".replace("MANZ.", "").replace(" ", "")

    # Clasificaci√≥n
    v_tipo = "Tipo A1"
    for t_nombre, lista in tipos_ref.items():
        if id_busqueda in lista:
            v_tipo = t_nombre
            break

    # Guardamos en el diccionario de tipos usando la llave exacta que usar√° el GeoJSON
    dict_tipos_vivienda[(mapa_manzanas[i], mapa_numeros[i])] = v_tipo

print(f"‚úÖ Clasificaci√≥n forzada completada para {len(dict_tipos_vivienda)} pol√≠gonos.")
print(f"üìä Resumen: { {t: list(dict_tipos_vivienda.values()).count(t) for t in set(dict_tipos_vivienda.values())} }")

# --- PASO FINAL: ACTUALIZAR EL MAPA ---
# Esta parte es vital para que el Popup reconozca el tipo
features_actualizados = []
for i, geo in enumerate(casas_geometria):
    mz = mapa_manzanas[i]
    num = mapa_numeros[i]
    avance = dict_avances.get((mz, num), 0.0)
    detalles = dict_detalles_casas.get((mz, num), [])
    tipo_v = dict_tipos_vivienda.get((mz, num), "Tipo A1")

    features_actualizados.append({
        "type": "Feature",
        "geometry": {"type": "Polygon", "coordinates": [geo]},
        "properties": {
            "manzana": mz,
            "numero": num,
            "tipo": tipo_v, # <--- Ahora el GeoJSON sabe qu√© tipo es
            "avance": avance,
            "detalles": detalles
        }
    })

print("‚úÖ GeoJSON actualizado con tipos de vivienda. Ahora puedes generar el mapa.")

# ========================================================
# RECONSTRUCCI√ìN DE AVANCES CON FILTRO POR TIPO DE VIVIENDA
# ========================================================

dict_detalles_casas_filtrado = {}
dict_avances_filtrado = {}

def partida_aplica_a_vivienda(codigo_partida, tipo_v, mz, casa):
    reglas = {
        "B.4.4.1": {"A1", "A1-N", "A2"},
        "B.4.4.2": {"A1", "A1-N", "A2"},
        "B.5.3.1": {"A1", "A1-N", "A2"},
        "C.2.3.1.B": {"A1-N"},
        "C.5.4": {"A1", "A1-N", "A2", "B"},
        "C.7.1": {"A1", "A1-N", "A2"},
        "C.9.3.1": {"A1", "A1-N", "A2", "B"},
        "C.EX.3": {"A1-N", "D"},
        "C.EX.14.1": {"A1-N", "B", "C", "D"},
        "C.EX.15": {"A1-N", "B"},
        "C.EX.16": {"C", "D"},
        "D.1.3": {"C", "D"},
        "D.1.4": {"A1", "A1-N", "A2"},
        "D.1.5": {"C", "D"},
        "D.1.8": {"C", "D"},
        "D.1.9": {"C", "D"},
        "D.1.10": {"C", "D"},
        "D.1.11": {"C", "D"},
        "D.1.12": {"C", "D"},
        "D.4.5.4": {"D"},
        "D.EX.3": {"A1-N", "D"},
        "D.EX.4": {"B"},
    }

    if codigo_partida not in reglas:
        return True

    return tipo_v in reglas[codigo_partida]

# ========================================================
# FILTRADO REAL
# ========================================================

for key, lista_partidas in dict_detalles_casas.items():
    mz, casa = key
    tipo_v = dict_tipos_vivienda.get(key, "A1")

    filtradas = []

    for p in lista_partidas:
        partida_raw = p.get("partida", "")
        match = re.search(r'\[(.*?)\]', partida_raw)
        codigo = match.group(1).strip() if match else ""

        if partida_aplica_a_vivienda(codigo, tipo_v, mz, casa):
            filtradas.append(p)

    if filtradas:
        dict_detalles_casas_filtrado[key] = filtradas

        total_p = len(filtradas)
        hechas = sum(1 for p in filtradas if p['estado'] == "‚úÖ")
        dict_avances_filtrado[key] = round((hechas / total_p) * 100, 1)

print(f"‚úÖ Avances recalculados con filtro por tipo de vivienda: {len(dict_avances_filtrado)} casas")

avance_total_obra = round(
    sum(dict_avances_filtrado.values()) / len(dict_avances_filtrado), 1
)

print(f"üèóÔ∏è Avance total de la obra: {avance_total_obra}%")

# --- PASO FINAL: VINCULAR DATOS DEL EXCEL AL MAPA ---

# Suponiendo que ya tienes tu lista de casas_geometria y mapa_manzanas/mapa_numeros
features = []

for i, geo in enumerate(casas_geometria):
    mz = mapa_manzanas[i]
    num = mapa_numeros[i]

    # Buscamos el avance en el diccionario que creamos antes
    # Si no existe, ponemos 0.0
    avance_vivienda = dict_avances.get((mz, num), 0.0)

    features.append({
        "type": "Feature",
        "geometry": {
            "type": "Polygon",
            "coordinates": [geo]
        },
        "properties": {
            "manzana": mz,
            "numero": num,
            "avance": avance_vivienda  # <--- AQU√ç SE INYECTA EL DATO REAL
        }
    })

# Ahora, al definir el estilo_hover, el color cambiar√° autom√°ticamente seg√∫n el Excel
def estilo_hover(feature):
    avance = feature["properties"]["avance"]

    # Escala de colores (Sem√°foro)
    if avance >= 90:
        color = "#27ae60"   # Verde fuerte (Terminado)
    elif avance >= 50:
        color = "#f1c40f"   # Amarillo (En proceso medio)
    elif avance > 0:
        color = "#e67e22"   # Naranja (Iniciando)
    else:
        color = "#c0392b"   # Rojo (Sin avance)

    return {
        "fillColor": color,
        "fillOpacity": 0.7,
        "weight": 2,
        "color": "black"
    }

print("‚úÖ Datos de avance vinculados a los pol√≠gonos del plano.")

# --- TEST DE CRUCE ---
print(f"1. Casas con obs detectadas en Google Sheet: {casas_con_obs}")

# Tomamos una casa de ejemplo que t√∫ SEPAS que tiene observaci√≥n
for (mz, num) in casas_con_obs:
    key = (mz, num)
    if key in dict_detalles_casas:
        print(f"‚úÖ La casa {key} existe en el mapa.")
        # Verificamos las partidas de esa casa
        partidas_en_excel = [p['partida'] for p in dict_detalles_casas[key]]
        print(f"   Partidas encontradas en Excel para esta casa: {partidas_en_excel[:3]}... (mostrando 3)")
    else:
        print(f"‚ùå La casa {key} NO existe en el diccionario del mapa. Revisa si en el mapa se llama 'MZ {mz}' o solo '{mz}'")

def generar_html_popup(manzana, casa_num, detalles):
    avance = dict_avances.get((manzana, casa_num), 0)

    resumen = {}
    for d in detalles:
        t, s = d['titulo'], d['subtitulo']
        if t not in resumen:
            resumen[t] = {'total': 0, 'listo': 0, 'subs': {}, 'obs': False}
        resumen[t]['total'] += 1
        if d['estado'] == "‚úÖ": resumen[t]['listo'] += 1
        if d.get('tiene_obs'): resumen[t]['obs'] = True
        if s:
            if s not in resumen[t]['subs']:
                resumen[t]['subs'][s] = {'total': 0, 'listo': 0, 'obs': False}
            resumen[t]['subs'][s]['total'] += 1
            if d['estado'] == "‚úÖ": resumen[t]['subs'][s]['listo'] += 1
            if d.get('tiene_obs'): resumen[t]['subs'][s]['obs'] = True

    html = f"""
    <div style="font-family: 'Segoe UI', Arial; width: 520px; background: white; margin: -15px -10px -10px -10px;">
        <div style="background: #2c3e50; color: white; padding: 15px 10px; display: flex; justify-content: space-between; align-items: center;">
            <h4 style="margin: 0; font-size: 16px;">MZ {manzana} - Casa {casa_num}</h4>
            <span style="background: #27ae60; padding: 3px 10px; border-radius: 12px; font-size: 12px; font-weight: bold;">{avance}% Avance</span>
        </div>

        <div style="display: flex; height: 380px;">
            <div style="flex: 1.8; overflow-y: auto; padding: 10px; border-right: 1px solid #eee;" id="lista_partidas">
                <table style="width: 100%; border-collapse: collapse; table-layout: fixed;">
                    <colgroup>
                        <col style="width: 85%;">
                        <col style="width: 15%;">
                    </colgroup>
    """

    current_tit, current_sub = None, None
    for item in detalles:
        if item['titulo'] != current_tit:
            current_tit = item['titulo']
            anchor_tit = f"tit_{hash(current_tit)}"
            html += f'<tr id="{anchor_tit}" style="background: #edeff0;"><td colspan="2" style="padding: 10px 5px; font-weight: bold; color: #2c3e50; border-top: 2px solid #2c3e50;">{current_tit.upper()}</td></tr>'

        if item['subtitulo'] != current_sub:
            current_sub = item['subtitulo']
            if current_sub:
                anchor_sub = f"sub_{hash(current_sub)}"
                html += f'<tr id="{anchor_sub}" style="background: #f9f9f9;"><td colspan="2" style="padding: 6px 8px; font-weight: bold; color: #7f8c8d; font-style: italic; border-bottom: 1px solid #eee;">‚Ü≥ {current_sub}</td></tr>'

        if item.get('tiene_obs'):
            color_st = "#d4a017"
            icono_mostrado = "‚ö†Ô∏è"
            comentario = item.get("comentario", "Sin detalle")
            # ACORDE√ìN NATIVO: No usa JS, no falla.
            nombre_partida = f"""
            <div style="padding: 2px 0;">
                <b style="color: #d4a017;">{item['partida']}</b>
                <details style="margin-top: 4px;">
                    <summary style="cursor: pointer; color: #856404; font-size: 10px; font-weight: bold; outline: none;">
                        Ver nota [+]
                    </summary>
                    <div style="margin-top: 4px; padding: 8px; background: #fff9e6; border-left: 3px solid #d4a017; color: #856404; font-size: 10px; line-height: 1.4; word-wrap: break-word;">
                        {comentario}
                    </div>
                </details>
            </div>
            """
        else:
            color_st = "#27ae60" if item['estado'] == "‚úÖ" else "#e74c3c"
            icono_mostrado = item['estado']
            nombre_partida = f"<span style='color: #444; font-size: 11px;'>{item['partida']}</span>"

        html += f"""
            <tr style="border-bottom: 1px solid #f2f2f2;">
                <td style="padding: 8px 10px; vertical-align: top;">{nombre_partida}</td>
                <td style="padding: 8px 5px; text-align: center; color: {color_st}; font-weight: bold; font-size: 14px; vertical-align: top;">{icono_mostrado}</td>
            </tr>
        """

    html += """</table></div>
            <div style="flex: 1.2; background: #f4f7f8; padding: 10px; overflow-y: auto; border-left: 1px solid #ddd;">
                <div style="font-size: 11px; font-weight: bold; color: #95a5a6; margin-bottom: 10px; text-align: center; border-bottom: 1px solid #ccc; padding-bottom: 5px;">√çNDICE DE CONTROL</div>"""

    for tit, datos in resumen.items():
        anchor_tit = f"tit_{hash(tit)}"
        bg_tit = "#fff3cd" if datos['obs'] else "#fff"
        html += f"""
        <div onclick="document.getElementById('{anchor_tit}').scrollIntoView({{behavior: 'smooth'}})"
             style="cursor: pointer; padding: 6px; background: {bg_tit}; border: 1px solid #dcdde1; border-radius: 4px; margin-bottom: 4px;">
            <div style="font-weight: bold; color: #2c3e50; font-size: 10px;">{tit}</div>
            <div style="font-size: 9px; color: {'#856404' if datos['obs'] else '#27ae60'};">{datos['listo']}/{datos['total']} completados</div>
        </div>"""

        for subtit, sdatos in datos['subs'].items():
            anchor_sub = f"sub_{hash(subtit)}"
            estilo_s = "color: #856404; font-weight: bold;" if sdatos['obs'] else "color: #636e72;"
            html += f"""
            <div onclick="document.getElementById('{anchor_sub}').scrollIntoView({{behavior: 'smooth'}})"
                  style="cursor: pointer; padding: 4px 6px 4px 15px; margin-bottom: 3px; border-left: 2px solid {'#f1c40f' if sdatos['obs'] else '#bdc3c7'}; font-size: 9px; {estilo_s}">
                <span>{subtit} {'(!)' if sdatos['obs'] else ''}</span>
            </div>"""

    html += "</div></div></div>"
    return html

# TEST DE VERIFICACI√ìN R√ÅPIDA
encontrados = 0
for casa, lista in dict_detalles_casas.items():
    for p in lista:
        if p['tiene_obs']:
            print(f"‚úÖ ¬°√âXITO! En la casa {casa} encontramos la partida: {p['partida']}")
            print(f"   Mensaje: {p['comentario']}")
            encontrados += 1

if encontrados == 0:
    print("‚ùå Seguimos sin encontrar coincidencias. Revisa si la partida en Google Sheet est√° escrita MUY diferente al Excel.")

def estilo_base(feature):
    avance = feature['properties'].get('avance', 0)
    # Colores: Rojo (0), Amarillo (1-99), Verde (100)
    color = '#e74c3c' if avance == 0 else '#f1c40f' if avance < 100 else '#27ae60'
    return {
        'fillColor': color,
        'color': 'black',
        'weight': 1,
        'fillOpacity': 0.4
    }

def estilo_hover(feature):
    return {
        'fillColor': '#2980b9', # Azul al pasar el cursor
        'color': 'white',
        'weight': 3,
        'fillOpacity': 0.7
    }

import folium

# 1. Configuraci√≥n del Mapa (Versi√≥n Antigua Estable)
limites = [[0, 0], [h, w]]
m = folium.Map(location=[h/2, w/2], zoom_start=0, crs='Simple', tiles=None)
folium.raster_layers.ImageOverlay(image='plano.png', bounds=limites, zindex=1).add_to(m)

# 2. Nueva L√≥gica de Colores (Basada en tus instrucciones)
def obtener_color_estatico(avance, tiene_obs):
    if tiene_obs:
        return "#f1c40f"  # Amarillo (Prioridad: Observaci√≥n)
    if avance > 80:
        return "#27ae60"  # Verde
    if 30 <= avance <= 80:
        return "#2980b9"  # Azul
    return "#c0392b"      # Rojo (Menor a 30%)

# 3. Bucle de Generaci√≥n
print("Generando mapa con vinculaci√≥n de datos...")

for i, geo in enumerate(casas_geometria):
    # Recuperamos Manzana y N√∫mero con limpieza de datos
    mz = str(mapa_manzanas.get(i, "SIN"))
    try:
        # Forzamos a que el n√∫mero sea entero para que coincida con el Excel
        num = int(float(mapa_numeros.get(i, 0)))
    except:
        num = 0

    key = (mz, num)

    # VINCULACI√ìN CR√çTICA: Recuperar avance y detalles
    avance_val = dict_avances.get(key, 0)
    detalles = dict_detalles_casas.get(key, [])
    tiene_observacion = any(d.get('tiene_obs') for d in detalles)

    # Definimos el color seg√∫n tu nueva regla
    color_casa = obtener_color_estatico(avance_val, tiene_observacion)

    # Preparar el HTML del Popup (Acorde√≥n)
    if detalles:
        popup_html = generar_html_popup(mz, num, detalles)
    else:
        popup_html = f"<div style='font-family:Arial;width:200px;'><b>Mzn {mz} Casa {num}</b><br>Avance: {avance_val}%<br>Sin detalles.</div>"

    # Estructura GeoJson con los datos corregidos
    feature_data = {
        "type": "Feature",
        "geometry": { "type": "Polygon", "coordinates": [geo] },
        "properties": {
            "manzana": mz,
            "numero": num,
            "avance": avance_val,
            "etiqueta_avance": f"{avance_val}%" # <--- Esto arregla el Tooltip
        }
    }

    # Dibujar la casa
    geo_layer = folium.GeoJson(
        feature_data,
        style_function=lambda x, c=color_casa: {
            "fillColor": c,
            "fillOpacity": 0.5, # Semitransparente como pediste
            "weight": 1.2,
            "color": "black"
        },
        highlight_function=lambda x: {"fillOpacity": 0.8, "weight": 2.5},
        tooltip=folium.GeoJsonTooltip(
            fields=["manzana", "numero", "etiqueta_avance"],
            aliases=["Manzana:", "Casa N¬∫:", "Avance Actual:"],
            sticky=True,
            style="font-family: Arial; font-size: 13px; border: 1px solid black;"
        )
    )

    # Agregar Popup y al Mapa
    geo_layer.add_child(folium.Popup(popup_html, max_width=500))
    geo_layer.add_to(m)

m.fit_bounds(limites)

def generar_html_popup(manzana, casa_num, detalles, tipo_vivienda):
    avance = dict_avances.get((manzana, casa_num), 0)

    resumen = {}
    for d in detalles:
        t, s = d['titulo'], d['subtitulo']
        if t not in resumen:
            resumen[t] = {'total': 0, 'listo': 0, 'subs': {}, 'obs': False}
        resumen[t]['total'] += 1
        if d['estado'] == "‚úÖ": resumen[t]['listo'] += 1
        if d.get('tiene_obs'): resumen[t]['obs'] = True
        if s:
            if s not in resumen[t]['subs']:
                resumen[t]['subs'][s] = {'total': 0, 'listo': 0, 'obs': False}
            resumen[t]['subs'][s]['total'] += 1
            if d['estado'] == "‚úÖ": resumen[t]['subs'][s]['listo'] += 1
            if d.get('tiene_obs'): resumen[t]['subs'][s]['obs'] = True

    html = f"""
    <div style="font-family: 'Segoe UI', Arial; width: 520px; background: white; margin: -15px -10px -10px -10px;">
        <div style="background: #2c3e50; color: white; padding: 15px 10px; display: flex; justify-content: space-between; align-items: center;">
            <h4 style="margin: 0; font-size: 16px;">MZ {manzana} - Casa {casa_num} - {tipo_vivienda}</h4>
            <span style="background: #27ae60; padding: 3px 10px; border-radius: 12px; font-size: 12px; font-weight: bold;">{avance}% Avance</span>
        </div>

        <div style="display: flex; height: 380px;">
            <div style="flex: 1.8; overflow-y: auto; padding: 10px; border-right: 1px solid #eee;" id="lista_partidas">
                <table style="width: 100%; border-collapse: collapse; table-layout: fixed;">
                    <colgroup>
                        <col style="width: 85%;">
                        <col style="width: 15%;">
                    </colgroup>
    """

    current_tit, current_sub = None, None
    for item in detalles:
        if item['titulo'] != current_tit:
            current_tit = item['titulo']
            anchor_tit = f"tit_{hash(current_tit)}"
            html += f'<tr id="{anchor_tit}" style="background: #edeff0;"><td colspan="2" style="padding: 10px 5px; font-weight: bold; color: #2c3e50; border-top: 2px solid #2c3e50;">{current_tit.upper()}</td></tr>'

        if item['subtitulo'] != current_sub:
            current_sub = item['subtitulo']
            if current_sub:
                anchor_sub = f"sub_{hash(current_sub)}"
                html += f'<tr id="{anchor_sub}" style="background: #f9f9f9;"><td colspan="2" style="padding: 6px 8px; font-weight: bold; color: #7f8c8d; font-style: italic; border-bottom: 1px solid #eee;">‚Ü≥ {current_sub}</td></tr>'

        if item.get('tiene_obs'):
            color_st = "#d4a017"
            icono_mostrado = "‚ö†Ô∏è"
            comentario = item.get("comentario", "Sin detalle")
            nombre_partida = f"""
            <div style="padding: 2px 0;">
                <b style="color: #d4a017;">{item['partida']}</b>
                <details style="margin-top: 4px;">
                    <summary style="cursor: pointer; color: #856404; font-size: 10px; font-weight: bold; outline: none;">
                        Ver nota [+]
                    </summary>
                    <div style="margin-top: 4px; padding: 8px; background: #fff9e6; border-left: 3px solid #d4a017; color: #856404; font-size: 10px; line-height: 1.4; word-wrap: break-word;">
                        {comentario}
                    </div>
                </details>
            </div>
            """
        else:
            color_st = "#27ae60" if item['estado'] == "‚úÖ" else "#e74c3c"
            icono_mostrado = item['estado']
            nombre_partida = f"<span style='color: #444; font-size: 11px;'>{item['partida']}</span>"

        html += f"""
            <tr style="border-bottom: 1px solid #f2f2f2;">
                <td style="padding: 8px 10px; vertical-align: top;">{nombre_partida}</td>
                <td style="padding: 8px 5px; text-align: center; color: {color_st}; font-weight: bold; font-size: 14px; vertical-align: top;">{icono_mostrado}</td>
            </tr>
        """

    html += """</table></div>
            <div style="flex: 1.2; background: #f4f7f8; padding: 10px; overflow-y: auto; border-left: 1px solid #ddd;">
                <div style="font-size: 11px; font-weight: bold; color: #95a5a6; margin-bottom: 10px; text-align: center; border-bottom: 1px solid #ccc; padding-bottom: 5px;">√çNDICE DE CONTROL</div>"""

    for tit, datos in resumen.items():
        anchor_tit = f"tit_{hash(tit)}"
        bg_tit = "#fff3cd" if datos['obs'] else "#fff"
        html += f"""
        <div onclick="document.getElementById('{anchor_tit}').scrollIntoView({{behavior: 'smooth'}})"
             style="cursor: pointer; padding: 6px; background: {bg_tit}; border: 1px solid #dcdde1; border-radius: 4px; margin-bottom: 4px;">
            <div style="font-weight: bold; color: #2c3e50; font-size: 10px;">{tit}</div>
            <div style="font-size: 9px; color: {'#856404' if datos['obs'] else '#27ae60'};">{datos['listo']}/{datos['total']} completados</div>
        </div>"""

        for subtit, sdatos in datos['subs'].items():
            anchor_sub = f"sub_{hash(subtit)}"
            estilo_s = "color: #856404; font-weight: bold;" if sdatos['obs'] else "color: #636e72;"
            html += f"""
            <div onclick="document.getElementById('{anchor_sub}').scrollIntoView({{behavior: 'smooth'}})"
                  style="cursor: pointer; padding: 4px 6px 4px 15px; margin-bottom: 3px; border-left: 2px solid {'#f1c40f' if sdatos['obs'] else '#bdc3c7'}; font-size: 9px; {estilo_s}">
                <span>{subtit} {'(!)' if sdatos['obs'] else ''}</span>
            </div>"""

    html += "</div></div></div>"
    return html

import folium

# 1. Configuraci√≥n del Mapa (Versi√≥n Antigua Estable)
limites = [[0, 0], [h, w]]
m = folium.Map(location=[h/2, w/2], zoom_start=0, crs='Simple', tiles=None)
folium.raster_layers.ImageOverlay(image='plano.png', bounds=limites, zindex=1).add_to(m)

# 2. Nueva L√≥gica de Colores
def obtener_color_estatico(avance, tiene_obs):
    if tiene_obs:
        return "#f1c40f"  # Amarillo (Prioridad: Observaci√≥n)
    if avance > 80:
        return "#27ae60"  # Verde
    if 30 <= avance <= 80:
        return "#2980b9"  # Azul
    return "#c0392b"      # Rojo

# 3. Bucle de Generaci√≥n
print("Generando mapa con vinculaci√≥n de datos y tipos...")

for i, geo in enumerate(casas_geometria):
    # Recuperamos Manzana y N√∫mero
    mz = str(mapa_manzanas.get(i, "SIN"))
    try:
        num = int(float(mapa_numeros.get(i, 0)))
    except:
        num = 0

    key = (mz, num)

    # VINCULACI√ìN: Recuperar avance, detalles y TIPO
    avance_val = dict_avances.get(key, 0)
    detalles = dict_detalles_casas.get(key, [])
    tiene_observacion = any(d.get('tiene_obs') for d in detalles)

    # Extraemos el tipo del diccionario que creaste en el bloque anterior
    tipo_v = dict_tipos_vivienda.get(key, "Tipo A1")

    # Definimos el color
    color_casa = obtener_color_estatico(avance_val, tiene_observacion)

    # Preparar el HTML del Popup (Pasamos tipo_v como nuevo argumento)
    if detalles:
        popup_html = generar_html_popup(mz, num, detalles, tipo_v)
    else:
        popup_html = f"<div style='font-family:Arial;width:200px;'><b>Mzn {mz} Casa {num} - {tipo_v}</b><br>Avance: {avance_val}%<br>Sin detalles.</div>"

    # Estructura GeoJson con 'tipo' incluido para el Tooltip
    feature_data = {
        "type": "Feature",
        "geometry": { "type": "Polygon", "coordinates": [geo] },
        "properties": {
            "manzana": mz,
            "numero": num,
            "tipo": tipo_v, # <--- Se agrega para el tooltip
            "avance": avance_val,
            "etiqueta_avance": f"{avance_val}%"
        }
    }

    # Dibujar la casa
    geo_layer = folium.GeoJson(
        feature_data,
        style_function=lambda x, c=color_casa: {
            "fillColor": c,
            "fillOpacity": 0.5,
            "weight": 1.2,
            "color": "black"
        },
        highlight_function=lambda x: {"fillOpacity": 0.8, "weight": 2.5},
        tooltip=folium.GeoJsonTooltip(
            fields=["manzana", "numero", "tipo", "etiqueta_avance"], # <--- Agregamos "tipo" aqu√≠
            aliases=["Manzana:", "Casa N¬∫:", "Tipo:", "Avance Actual:"], # <--- Agregamos etiqueta aqu√≠
            sticky=True,
            style="font-family: Arial; font-size: 13px; border: 1px solid black;"
        )
    )

    # Agregar Popup y al Mapa
    geo_layer.add_child(folium.Popup(popup_html, max_width=520))
    geo_layer.add_to(m)

m.fit_bounds(limites)

REGLAS_PARTIDAS = {
    "B.4.4.1": {"tipos": {"Tipo A1", "Tipo A1-N", "Tipo A2"}},
    "B.4.4.2": {"tipos": {"Tipo A1", "Tipo A1-N", "Tipo A2"}},
    "B.5.3.1": {"tipos": {"Tipo A1", "Tipo A1-N", "Tipo A2"}},
    "C.2.3.1.B": {"tipos": {"Tipo A1-N"}},
    "C.5.4": {"tipos": {"Tipo A1", "Tipo A1-N", "Tipo A2", "Tipo B"}},
    "C.7.1": {"tipos": {"Tipo A1", "Tipo A1-N", "Tipo A2"}},
    "C.9.3.1": {"tipos": {"Tipo A1", "Tipo A1-N", "Tipo A2", "Tipo B"}},
    "C.EX.3":  {"tipos": {"Tipo A1-N", "Tipo D"}},
    "C.EX.14.1": {"tipos": {"Tipo A1-N", "Tipo B", "Tipo C", "Tipo D"}},
    "C.EX.15": {"tipos": {"Tipo A1-N", "Tipo B"}},
    "C.EX.16": {"tipos": {"Tipo C", "Tipo D"}},
    "C.EX.18": {"tipos": {"Tipo B", "Tipo C"}},
    "D.1.3": {"tipos": {"Tipo C", "Tipo D"}},
    "D.1.4": {"tipos": {"Tipo A1", "Tipo A1-N", "Tipo A2"}},
    "D.1.5": {"tipos": {"Tipo C", "Tipo D"}},
    "D.1.8": {"tipos": {"Tipo C", "Tipo D"}},
    "D.1.9": {"tipos": {"Tipo C", "Tipo D"}},
    "D.1.10": {"tipos": {"Tipo C", "Tipo D"}},
    "D.1.11": {"tipos": {"Tipo C", "Tipo D"}},
    "D.1.12": {"tipos": {"Tipo C", "Tipo D"}},
    "D.4.5.4": {"tipos": {"Tipo D"}},
    "D.EX.3": {"tipos": {"Tipo A1-N", "Tipo D"}},
    "D.EX.4": {"tipos": {"Tipo B"}},
}

import re

def extraer_codigo_partida(partida_raw):
    """
    Extrae el c√≥digo tipo C.EX.15 desde strings como:
    '[C.EX.15] Proteccion Metalica Ventana'
    """
    if not partida_raw:
        return None

    match = re.search(r'\[([A-Z0-9\.]+)\]', partida_raw)
    return match.group(1) if match else None

def partida_aplica(partida_raw, tipo_vivienda, manzana, casa):
    codigo = extraer_codigo_partida(partida_raw)

    # Si no logramos identificar el c√≥digo ‚Üí NO filtramos
    if not codigo:
        return True

    if codigo not in REGLAS_PARTIDAS:
        return True

    regla = REGLAS_PARTIDAS[codigo]

    if tipo_vivienda in regla.get("tipos", set()):
        return True

    if "excepciones" in regla:
        if (str(manzana), str(casa)) in regla["excepciones"]:
            return True

    return False

def generar_html_popup(manzana, casa_num, detalles, tipo_vivienda, avance):

    detalles = [
        d for d in detalles
        if partida_aplica(
            d.get("partida"),
            tipo_vivienda,
            manzana,
            casa_num
        )
    ]

    for d in detalles:
        if not partida_aplica(d.get("partida"), tipo_vivienda, manzana, casa_num):
            print("FILTRADA:", manzana, casa_num, d.get("partida"))

    resumen = {}
    for d in detalles:
        t, s = d['titulo'], d['subtitulo']
        if t not in resumen:
            resumen[t] = {'total': 0, 'listo': 0, 'subs': {}, 'obs': False}
        resumen[t]['total'] += 1
        if d['estado'] == "‚úÖ":
            resumen[t]['listo'] += 1
        if d.get('tiene_obs'):
            resumen[t]['obs'] = True
        if s:
            if s not in resumen[t]['subs']:
                resumen[t]['subs'][s] = {'total': 0, 'listo': 0, 'obs': False}
            resumen[t]['subs'][s]['total'] += 1
            if d['estado'] == "‚úÖ":
                resumen[t]['subs'][s]['listo'] += 1
            if d.get('tiene_obs'):
                resumen[t]['subs'][s]['obs'] = True

    html = f"""
    <div style="font-family: 'Segoe UI', Arial; width: 520px; background: white; margin: -15px -10px -10px -10px;">
        <div style="background: #2c3e50; color: white; padding: 15px 10px; display: flex; justify-content: space-between; align-items: center;">
            <h4 style="margin: 0; font-size: 16px;">
                MZ {manzana} - Casa {casa_num} - {tipo_vivienda}
            </h4>
            <div style="width: 160px;">
                <div style="font-size: 12px; font-weight: bold; text-align: right;">
                    {avance}%
                </div>
                <div style="background: #dcdde1; border-radius: 6px;
                            height: 8px; overflow: hidden;">
                    <div style="
                        width: {avance}%;
                        height: 100%;
                        background: linear-gradient(90deg, #2980b9, #27ae60);
                    "></div>
                </div>
            </div>
        </div>

        <div style="display: flex; height: 380px;">
            <div style="flex: 1.8; overflow-y: auto; padding: 10px; border-right: 1px solid #eee;" id="lista_partidas">
                <table style="width: 100%; border-collapse: collapse; table-layout: fixed;">
                    <colgroup>
                        <col style="width: 85%;">
                        <col style="width: 15%;">
                    </colgroup>
    """

    current_tit, current_sub = None, None
    for item in detalles:
        if item['titulo'] != current_tit:
            current_tit = item['titulo']
            anchor_tit = f"tit_{hash(current_tit)}"
            html += f"""
            <tr id="{anchor_tit}" style="background: #edeff0;">
                <td colspan="2" style="padding: 10px 5px; font-weight: bold;
                    color: #2c3e50; border-top: 2px solid #2c3e50;">
                    {current_tit.upper()}
                </td>
            </tr>
            """

        if item['subtitulo'] != current_sub:
            current_sub = item['subtitulo']
            if current_sub:
                anchor_sub = f"sub_{hash(current_sub)}"
                html += f"""
                <tr id="{anchor_sub}" style="background: #f9f9f9;">
                    <td colspan="2" style="padding: 6px 8px; font-weight: bold;
                        color: #7f8c8d; font-style: italic; border-bottom: 1px solid #eee;">
                        ‚Ü≥ {current_sub}
                    </td>
                </tr>
                """

        if item.get('tiene_obs'):
            color_st = "#d4a017"
            icono_mostrado = "‚ö†Ô∏è"
            comentario = item.get("comentario", "Sin detalle")
            nombre_partida = f"""
            <div style="padding: 2px 0;">
                <b style="color: #d4a017;">{item['partida']}</b>
                <details style="margin-top: 4px;">
                    <summary style="cursor: pointer; color: #856404;
                        font-size: 10px; font-weight: bold; outline: none;">
                        Ver nota [+]
                    </summary>
                    <div style="margin-top: 4px; padding: 8px; background: #fff9e6;
                        border-left: 3px solid #d4a017; color: #856404;
                        font-size: 10px; line-height: 1.4;">
                        {comentario}
                    </div>
                </details>
            </div>
            """
        else:
            color_st = "#27ae60" if item['estado'] == "‚úÖ" else "#e74c3c"
            icono_mostrado = item['estado']
            nombre_partida = f"""
            <span style='color: #444; font-size: 11px;'>
                {item['partida']}
            </span>
            """

        html += f"""
        <tr style="border-bottom: 1px solid #f2f2f2;">
            <td style="padding: 8px 10px; vertical-align: top;">
                {nombre_partida}
            </td>
            <td style="padding: 8px 5px; text-align: center;
                color: {color_st}; font-weight: bold; font-size: 14px;">
                {icono_mostrado}
            </td>
        </tr>
        """

    html += """</table></div>
        <div style="flex: 1.2; background: #f4f7f8; padding: 10px;
            overflow-y: auto; border-left: 1px solid #ddd;">
            <div style="font-size: 11px; font-weight: bold; color: #95a5a6;
                margin-bottom: 10px; text-align: center;
                border-bottom: 1px solid #ccc; padding-bottom: 5px;">
                √çNDICE DE CONTROL
            </div>
    """

    for tit, datos in resumen.items():
        anchor_tit = f"tit_{hash(tit)}"
        bg_tit = "#fff3cd" if datos['obs'] else "#fff"
        html += f"""
        <div onclick="document.getElementById('{anchor_tit}')
                .scrollIntoView({{behavior:'smooth'}})"
            style="cursor: pointer; padding: 6px; background: {bg_tit};
            border: 1px solid #dcdde1; border-radius: 4px; margin-bottom: 4px;">
            <div style="font-weight: bold; color: #2c3e50; font-size: 10px;">
                {tit}
            </div>
            <div style="font-size: 9px;
                color: {'#856404' if datos['obs'] else '#27ae60'};">
                {datos['listo']}/{datos['total']} completados
            </div>
        </div>
        """

        for subtit, sdatos in datos['subs'].items():
            anchor_sub = f"sub_{hash(subtit)}"
            estilo_s = "color:#856404;font-weight:bold;" if sdatos['obs'] else "color:#636e72;"
            html += f"""
            <div onclick="document.getElementById('{anchor_sub}')
                    .scrollIntoView({{behavior:'smooth'}})"
                style="cursor:pointer; padding:4px 6px 4px 15px;
                margin-bottom:3px; border-left:2px solid
                {'#f1c40f' if sdatos['obs'] else '#bdc3c7'};
                font-size:9px; {estilo_s}">
                {subtit} {'(!)' if sdatos['obs'] else ''}
            </div>
            """

    html += "</div></div></div>"
    return html

import folium
from branca.element import Template, MacroElement

# 1. Configuraci√≥n del Mapa
limites = [[0, 0], [h, w]]
m = folium.Map(location=[h/2, w/2], zoom_start=0, crs='Simple', tiles=None)
folium.raster_layers.ImageOverlay(
    image='plano.png',
    bounds=limites,
    zindex=1
).add_to(m)

# 2. L√≥gica de colores
def obtener_color_estatico(avance, tiene_obs):
    if tiene_obs:
        return "#f2ca27"  # Amarillo
    if avance > 80:
        return "#36d278"  # Verde
    if 30 <= avance <= 80:
        return "#409ad5"  # Azul
    return "#d65548"      # Rojo

print("Generando mapa con partidas filtradas y avance recalculado...")

# 3. Generaci√≥n de viviendas
for i, geo in enumerate(casas_geometria):

    mz = str(mapa_manzanas.get(i, "SIN"))
    try:
        num = int(float(mapa_numeros.get(i, 0)))
    except:
        num = 0

    key = (mz, num)

    avance_val = dict_avances_filtrado.get(key, 0)
    detalles = dict_detalles_casas.get(key, [])
    tiene_observacion = any(d.get('tiene_obs') for d in detalles)

    tipo_v = dict_tipos_vivienda.get(key, "Tipo A1")

    color_casa = obtener_color_estatico(avance_val, tiene_observacion)

    if detalles:
        popup_html = generar_html_popup(mz, num, detalles, tipo_v, avance_val)
    else:
        popup_html = (
            f"<div style='font-family:Arial;width:200px;'>"
            f"<b>Mzn {mz} Casa {num} - {tipo_v}</b><br>"
            f"Avance: {avance_val}%<br>Sin detalles.</div>"
        )

    feature_data = {
        "type": "Feature",
        "geometry": {"type": "Polygon", "coordinates": [geo]},
        "properties": {
            "manzana": mz,
            "numero": num,
            "tipo": tipo_v,
            "avance": avance_val,
            "etiqueta_avance": f"""
            <div style="font-size:12px;font-weight:bold;text-align:right;">
                {avance_val}%
            </div>
            <div style="background:#e0e0e0;height:6px;border-radius:4px;overflow:hidden;">
                <div style="
                    width:{avance_val}%;
                    height:100%;
                    background:linear-gradient(90deg,#2980b9,#27ae60);
                "></div>
            </div>
            """
        }
    }

    geo_layer = folium.GeoJson(
        feature_data,
        style_function=lambda x, c=color_casa: {
            "fillColor": c,
            "fillOpacity": 0.5,
            "weight": 1.2,
            "color": "black"
        },
        highlight_function=lambda x: {
            "fillOpacity": 0.8,
            "weight": 2.5
        },
        tooltip=folium.GeoJsonTooltip(
            fields=["manzana", "numero", "tipo", "etiqueta_avance"],
            aliases=["Manzana:", "Casa N¬∫:", "Tipo:", "Avance:"],
            sticky=True,
            localize=True,
            labels=True,
            style="""
                background-color: white;
                border: 1px solid black;
                border-radius: 6px;
                box-shadow: 2px 2px 6px rgba(0,0,0,0.3);
                font-family: Arial;
                font-size: 12px;
            """
        )
    )

    geo_layer.add_child(folium.Popup(popup_html, max_width=520))
    geo_layer.add_to(m)

# 4. Overlay avance total obra
avance_total_obra = round(
    sum(dict_avances_filtrado.values()) / len(dict_avances_filtrado), 1
) if dict_avances_filtrado else 0

overlay_html = f"""
{{% macro html(this, kwargs) %}}
<div style="
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 9999;
    background: white;
    padding: 16px 18px;
    border-radius: 12px;
    box-shadow: 0 4px 14px rgba(0,0,0,0.25);
    font-family: Arial;
    width: 220px;
">
    <div style="font-weight: bold; font-size: 13px; margin-bottom: 8px;">
        Avance total viviendas
    </div>

    <div style="
        font-size: 26px;
        font-weight: bold;
        color: #2c7be5;
        text-align: center;
        margin-bottom: 8px;
    ">
        {avance_total_obra}%
    </div>

    <div style="
        background: #e0e0e0;
        border-radius: 8px;
        height: 12px;
        overflow: hidden;
    ">
        <div style="
            width: {avance_total_obra}%;
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            transition: width 0.6s ease;
        "></div>
    </div>
</div>
{{% endmacro %}}
"""

macro = MacroElement()
macro._template = Template(overlay_html)
m.get_root().add_child(macro)


m.fit_bounds(limites)
m